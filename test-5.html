<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CSV Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="author" content="Kevin Curley - chatgpt-8a.html - 2025-09-24">
  <style>
    :root{
      --gap:12px;
      --muted:#666;
      --card:#e9ecef;
      --bg:#f4f6f8;
      --accent:#0b67ff;
    }
    body{
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin:0;
      padding:20px;
      background:var(--bg);
      color:#111;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:14px;
    }
    h1{ margin:0; font-size:1.25rem; }
    .controls-card{
      background:var(--card);
      padding:12px;
      border-radius:10px;
      box-shadow:0 1px 4px rgba(0,0,0,0.06);
      margin-bottom:14px;
    }
    .controls-grid{
      display:grid;
      grid-template-columns:1fr 1fr 1fr;
      gap:var(--gap);
      align-items:start;
    }
    .col{
      background:#fff;
      padding:10px;
      border-radius:8px;
      border:1px solid rgba(0,0,0,0.04);
      min-height:120px;
    }
    .col h3{ margin:0 0 8px 0; font-size:0.95rem; }
    .file-list { max-height:220px; overflow:auto; padding-right:6px; }
    .checkbox-list{ max-height:300px; overflow:auto; }
    .inline-row{ display:flex; gap:8px; align-items:center; margin-bottom:8px; }
    label{ font-size:0.95rem; }
    button{
      background:var(--accent);
      color:white;
      border:0;
      padding:8px 10px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
    }
	button.primary { background:#0b67ff; color:#fff; }
	button.success { background:#28a745; color:#fff; }
	button.danger  { background:#d9534f; color:#fff; }
    button.ghost{
      background:transparent;
      color:var(--accent);
      border:1px solid rgba(11,103,255,0.12);
      font-weight:600;
    }
    button.small{ padding:6px 8px; font-size:0.9rem; border-radius:6px; }
    .muted{ color:var(--muted); font-size:0.9rem; }
    .controls-actions{ display:flex; gap:8px; margin-top:10px; }
    .table-wrap{ background:var(--card); padding:12px; border-radius:10px; box-shadow:0 1px 4px rgba(0,0,0,0.05); }
    table{ width:100%; border-collapse:collapse; }
    th, td{ text-align:left; padding:8px 6px; border-bottom:1px solid #eef2f6; font-size:0.95rem; vertical-align:top; }
    th.sticky{ position:sticky; top:0; background:#fff; z-index:2; }
    .small-muted{ font-size:0.85rem; color:var(--muted); }
    .control-actions-row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
    .control-block{ background: #fff; padding:8px; border-radius:8px; border:1px solid rgba(0,0,0,0.04); margin-bottom:8px; }
    .row-actions{ display:flex; gap:8px; align-items:center; margin-top:6px; }
    .pill{ border-radius:999px; padding:4px 8px; border:1px solid #e1e7ee; background:#f9fbff; font-size:0.9rem; }
    .delete-x{ cursor:pointer; margin-left:8px; color:#b33; font-weight:700; }
    input[type="text"], select{
      width:100%;
      padding:6px 8px;
      border-radius:6px;
      border:1px solid #d7dee7;
      box-sizing:border-box;
    }
    .flex{ display:flex; gap:8px; align-items:center; }
    .right{ margin-left:auto; }
    .hidden{ display:none !important; }
    .file-input{ display:flex; gap:8px; align-items:center; }
    .small-note{ font-size:0.85rem; color:var(--muted); margin-top:6px; }
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .toggle-btn{ background:#0b67ff; color:#fff; border:1px solid rgba(0,0,0,0.06); padding:6px 8px; border-radius:8px; cursor:pointer; }
    .sr-only{ position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
    .no-data{ padding:20px; text-align:center; color:var(--muted); }
	/* Style rules for report-table */
	.table-style-RT { border-collapse: collapse; width: 100%; }
	.table-style-RT th, .table-style-RT td {
		border: 1px solid #ccc;
		padding: 2px;
		background-color: #f2f2f2;
		font-size: 12px;
	}
	h4 {  font-size: 0.8em; /* Relative to the parent's font size */ }
	.align-center { text-align: center; }
	.file-item {
		font-size: 12px; /* Corrected font size property */
		border-bottom: 1px dashed #eef2f6;
		cursor: pointer;
		color: blue;
	}
	.file-item:hover {
		/* Change color and/or other styles on hover */
		color: #004085; /* A darker blue for a subtle change */
		background-color: #f0f0f0;
		border-bottom: 1px dashed #004085; /* Change border color on hover */
	}
	.help-box {
		display: none; /* Hide the help box by default */
		position: absolute; /* Position it relative to the nearest positioned ancestor */
		background-color: #f9f9f9; /* Background color */
		border: 1px solid #ccc; /* Border */
		border-radius:8px;
		padding: 10px; /* Padding */
		z-index: 1000; /* Ensure it appears above other elements */
	}
	.help-hover:hover + .help-box {
		display: block; /* Show the help box on hover */
	}
}
  </style>
</head>
<body>

<header>
  <div>
    <h1 id="table-title">Table: <span id="table-name">workorders</span></h1>
    <div class="small-muted" id="table-sub">Loaded CSV: <span id="csv-loaded">â€”</span></div>
  </div>
  <div class="topbar">
    <input
  type="button"
  value="Download latest 2025 Work Orders"
  onclick="window.open('https://www.avalon-estates.com/admin2/requestmanager/export.php?act=export&category=1&status=0&staffid=&begin=01%2F01%2F2025&end=&submit=Submit', '_blank');"
  style="padding: 10px 20px; background-color: #007BFF; color: white; border: none; border-radius: 5px; cursor: pointer; font-family: Arial, sans-serif;"
> 
    <button id="toggle-controls" class="toggle-btn">Hide Controls</button>
    <div class="small-muted">Default table param: <code>?table=workorders</code></div>
  </div>
</header>

<section class="controls-card" id="controls-section">
  <div class="control-actions-row">
    <div class="pill">Controls</div>
    <div class="small-muted">Use the controls below to show/hide columns, add sorts and searches. Click Apply Changes to update the table.</div>
    <div class="right">
      <button id="apply-btn" class="danger">Apply Changes</button>
    </div>
  </div>

  <div class="controls-grid">
    <!-- Column 1: file list -->
    <div class="col" id="col-files">
	<h3 class="help-hover">1) CSV files (available on Server)</h3>
	<div class="help-box">If your server provides a file,<br>
						  csv-list.json (array of filenames),<br>
						  the file names will be show here.<br>
						  Otherwise use the 'Choose file'
						  <br> to display a local file.</div>
      <div class="file-list" id="file-list">
        <div class="muted small-note">Trying to fetch /csv-list.json for available files...</div>
      </div>

      <div style="margin-top:8px;">
        <div class="file-input">
          <input type="text" id="csv-url-input" placeholder="Paste a CSV URL (or leave empty to use ?table=...)" />
          <button id="load-url" class="small ghost">Load</button>
        </div>
        <div style="margin-top:8px;">
          <label class="small-muted">or load a local CSV file: <input type="file" id="local-file" accept=".csv" /></label>
        </div>
      </div>
	  <div id="report-table"></div>
    </div>

    <!-- Column 2: columns with checkboxes -->
    <div class="col" id="col-columns">
      <h3>2) Columns to display</h3>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <label><input type="checkbox" id="select-all-cols" /> Select all</label>
        <div class="small-muted">Toggle all column checkboxes</div>
      </div>
      <div class="checkbox-list" id="columns-list">
        <div class="small-muted">No CSV loaded yet.</div>
      </div>
    </div>

    <!-- Column 3: sort and search -->
    <div class="col" id="col-sort-search">
      <h3>3) Sort & Search</h3>

      <!-- Sort controls -->
      <div class="control-block" id="sort-block">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Sorts</strong>
          <div>
            <button id="add-sort" class="small">Add Sort</button>
            <button id="clear-sorts" class="small danger">Clear Sorts</button>
          </div>
        </div>
        <div id="sort-list" style="margin-top:8px;">
          <div class="small-muted">No sorts defined.</div>
        </div>
      </div>

      <!-- Search controls -->
      <div class="control-block" id="search-block">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Searches</strong>
          <div>
            <button id="add-search" class="small">Add Search</button>
            <button id="clear-searches" class="small danger">Clear Searches</button>
          </div>
        </div>
        <div id="search-list" style="margin-top:8px;">
          <div class="small-muted">No searches defined.</div>
        </div>
        <div class="small-note" style="margin-top:6px;">
          Up to 4 searches. Searches are combined with AND (rows must match all).
        </div>
      </div>

    </div>
  </div>

  <div class="controls-actions" style="margin-top:12px;">
    <button id="apply-bottom" class="danger">Apply Changes</button>
    <button id="reset-btn" class="ghost">Reset to defaults</button>
  </div>
</section>

<main>
  <div class="table-wrap">
    <div id="table-container">
      <div class="no-data">No data loaded yet.</div>
    </div>
  </div>
</main>

<script>
/*
 CSV Viewer
 - Reads ?table=... from URL (defaults to 'workorders')
 - Attempts to fetch <table>.csv (or if provided as url via input, uses that)
 - If '/csv-list.json' available it will populate "available files" list
 - Column selection, multi-sort, up to 4 searches
 - Date conversion from mm/dd/yyyy -> yyyy-mm-dd for sorting/searching/display
 - Apply Changes button applies filters/sorts and renders table
*/

// ----------------- Utilities -----------------
function qs(sel, el=document) { return el.querySelector(sel); }
function qsa(sel, el=document) { return Array.from(el.querySelectorAll(sel)); }
function escapeHtml(s){ if(s==null) return ''; return String(s).replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[c]); }
function getUrlParam(name){
  const params = new URLSearchParams(window.location.search);
  return params.get(name);
}
function ensureCsvExt(name){
  if(!name) return name;
  return name.toLowerCase().endsWith('.csv') ? name : (name + '.csv');
}

// Robust-ish CSV parser supporting quoted fields with commas/newlines inside quotes.
function parseCSV(text){
  // Return array of rows; first row is header.
  // Implement state machine
  const rows = [];
  let cur = [];
  let field = '';
  let i=0;
  const len = text.length;
  let inQuotes = false;
  while(i < len){
    const ch = text[i];
    if(inQuotes){
      if(ch === '"'){
        if(text[i+1] === '"'){ field += '"'; i += 2; continue; } // escaped quote
        else { inQuotes = false; i++; continue; }
      } else {
        field += ch;
        i++;
        continue;
      }
    } else {
      if(ch === '"'){ inQuotes = true; i++; continue; }
      if(ch === ','){ cur.push(field); field = ''; i++; continue; }
      if(ch === '\r'){
        // ignore, handle on \n
        i++; continue;
      }
      if(ch === '\n'){
        cur.push(field);
        rows.push(cur);
        cur = [];
        field = '';
        i++;
        continue;
      }
      field += ch;
      i++;
    }
  }
  // flush
  if(inQuotes){
    // malformed but flush anyway
    cur.push(field);
    rows.push(cur);
  } else {
    if(field !== '' || cur.length > 0){
      cur.push(field);
      rows.push(cur);
    }
  }
  return rows;
}

// Convert mm/dd/yyyy to yyyy-mm-dd (strict), else return original.
function mmddyyyy_to_iso(s){
  //console.log('mmddyyy_to_iso s=', s);
  if(!s) return s; 
  // trim spaces
  const t = s.trim();
  //KC - changed this code to allow for mm/dd/yy or mm/dd/yyyy
  let yyyy = null;
  let m = null;  
  if(/^\d{1,2}\/\d{1,2}\/\d{1,2}$/.test(t)){
		m = /^(\d{1,2})\/(\d{1,2})\/(\d{1,2})$/.exec(t);
		//console.log('s=', s, '  m[1]=', m[1], '  m[2]=', m[2], '  m[3]=', m[3]);	
		if(!m) return null;
		const yy = String(m[3]).padStart(2,'0');
		yyyy = "20" + yy;
		//console.log(`yyyy=${yyyy}`);
	} else if(/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(t)){
		m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(t);
		//console.log('s=', s, '  m[1]=', m[1], '  m[2]=', m[2], '  m[3]=', m[3]);	
		if(!m) return null;
		yyyy = m[3];
		//console.log(`yyyy=${yyyy}`);
	} else {
		return null;
  }	
  //const m = /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/.exec(t);   
  //if(!m) return null;
  //console.log('s=', s, '  m[1]=', m[1], '  m[2]=', m[2], '  m[3]=', m[3]);	  
  const mm = String(m[1]).padStart(2,'0');
  const dd = String(m[2]).padStart(2,'0');
  //console.log(`return: ${yyyy}-${mm}-${dd}`);
  //return `${yyyy}-${mm}-${dd}`;
  return `${yyyy}/${mm}/${dd}`;
}

// Try to coerce string to comparable value for sort/search
function coerceValue(val, detectDate){
  if(val == null) return '';
  if(typeof val !== 'string') return val;
  const t = val.trim();
  if(detectDate){
    const iso = mmddyyyy_to_iso(t);
    if(iso) return iso;
  }
  // numeric?
  if(/^-?\d+(\.\d+)?$/.test(t)) return Number(t);
  return t.toLowerCase();
}

// Multi-level sort comparator factory
function makeComparator(sortDefs, columnIndexMap, dateColumnSet){
  // sortDefs: [{col: "Name", dir:"asc"} , ... ] applied in order
  return function(a,b){
    for(const s of sortDefs){
      const col = s.col;
      const dir = s.dir === 'desc' ? -1 : 1;
      const idx = columnIndexMap[col];
      if(idx === undefined) continue;
      let va = a.__parsed && a.__parsed[idx] !== undefined ? a.__parsed[idx] : (a[idx] || '');
      let vb = b.__parsed && b.__parsed[idx] !== undefined ? b.__parsed[idx] : (b[idx] || '');
      // if date col, compare iso strings as strings
      if(dateColumnSet.has(col)){
        // if either null then treat empty as less
        if(va == null) va = '';
        if(vb == null) vb = '';
        if(va < vb) return -1 * dir;
        if(va > vb) return 1 * dir;
      } else {
        // coerce numbers, strings
        if(typeof va === 'string' && /^-?\d+(\.\d+)?$/.test(va)) va = Number(va);
        if(typeof vb === 'string' && /^-?\d+(\.\d+)?$/.test(vb)) vb = Number(vb);
        if(va < vb) return -1 * dir;
        if(va > vb) return 1 * dir;
      }
    }
    return 0;
  };
}

// Get the full URL of this execution for any queries in the javascript
console.log(`test-5.html  version 5.3`);
let fullUrl = window.location.href;
console.log(`The full URL is: ${fullUrl}`);
// Get just the URL path
let urlPath = window.location.pathname;
console.log(`The URL path is: ${urlPath}`);

// ----------------- App State -----------------
let state = {
  tableParam: getUrlParam('table') || 'workorders',
  csvUrl: null,
  rawText: null,
  header: [],
  rows: [], // arrays of cells
  parsedRows: [], // objects? we will store arrays plus __parsed representation for convenience
  visibleColumns: [], // array of header names to display
  sorts: [], // array of {id, col, dir}
  searches: [], // array of {id, col, value}
  dateColumns: new Set(), // header names that are dates
  availableFiles: [], // from /csv-list.json if available
  ticId: [], // from /tic-id.json if available
};

(function init(){
  // normalize table param & set title
  if(state.tableParam.toLowerCase().endsWith('.csv')) {
    // ok
  } else {
    // leave as given; we'll try to fetch with .csv appended
  }
  document.getElementById('table-name').textContent = state.tableParam;
  // wire up UI
  wireUI();
  tryFetchCsvList();
  let kc = 0;
  state.availableFiles.forEach(fname => {
    kc++;
	console.log(`(${kc})(${fname})`);
  });	
  tryFetchTicIdList();
  if ("1" == "2") {
  // attempt to auto-load from URL param
  const providedUrl = getUrlParam('csv-url'); // optional alternative param
  if(providedUrl){
    loadCsvFromUrl(providedUrl);
  } else {
    // default attempt: try fetch table param as given, with or without .csv
    tryAutoLoadTable(state.tableParam);
  }
  }
})();

// ----------------- UI wiring -----------------
function wireUI(){
  const toggle = qs('#toggle-controls');
  const section = qs('#controls-section');
  toggle.addEventListener('click', ()=>{
    if(section.classList.contains('hidden')){
      section.classList.remove('hidden');
      toggle.textContent = 'Hide Controls';
    } else {
      section.classList.add('hidden');
      toggle.textContent = 'Show Controls';
    }
  });

  qs('#load-url').addEventListener('click', ()=>{
    const url = qs('#csv-url-input').value.trim();
    if(!url){ alert('Please paste a CSV URL.'); return; }
    loadCsvFromUrl(url);
  });

  qs('#local-file').addEventListener('change', (ev)=>{
    const f = ev.target.files && ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = function(e){
      const text = e.target.result;
      state.csvUrl = 'local:' + f.name;
      state.rawText = text;
      processCsvText(text, f.name);
    };
    reader.readAsText(f);
  });

  qs('#apply-btn').addEventListener('click', applyChanges);
  qs('#apply-bottom').addEventListener('click', applyChanges);
  qs('#reset-btn').addEventListener('click', ()=>{
    // reset sorts/searches/columns to initial simple defaults
    state.sorts = [];
    state.searches = [];
    if(state.header && state.header.length){
      state.visibleColumns = [...state.header];
    }
    renderControls();
    renderTable();
  });

  qs('#select-all-cols').addEventListener('change', (ev)=>{
    const checked = ev.target.checked;
    qsa('.col-checkbox').forEach(cb => cb.checked = checked);
  });

  qs('#add-sort').addEventListener('click', ()=>{
    addSortControl();
  });
  qs('#clear-sorts').addEventListener('click', ()=>{
    state.sorts = [];
    renderControls();
  });

  qs('#add-search').addEventListener('click', ()=>{
    if(state.searches.length >= 4){ alert('Maximum 4 searches'); return; }
    addSearchControl();
  });
  qs('#clear-searches').addEventListener('click', ()=>{
    state.searches = [];
    renderControls();
  });

  // when user clicks a filename in file-list
  qs('#file-list').addEventListener('click', (ev)=>{
    const target = ev.target;
    if(target && target.dataset && target.dataset.file){
      const file = target.dataset.file;
      loadCsvFromUrl(file);
    }
  });
}

// ----------------- Ticket ID file list attempt -----------------
function tryFetchTicIdList(){
 console.log('tryFetchTicIdList: ');
 let ticIdName = 'tic-id.json';
 if ( fullUrl.toLowerCase().startsWith("http") && fullUrl.toLowerCase().includes("/workspace/") ) {
		// looks like we are using the workspace sever so set name 
		ticIdName = '/workspace/tic-id.json';
	}
 if ( fullUrl.toLowerCase().startsWith("file:") ) {
	// if we loaded html from a file the CORS policy won't allow local file access
	// so we'll just simulate a list for demo purposes and render files list
	console.log('tryFetchTicIdList: Simulating JSON file retrieval for demo purpose');
	state.ticId = ["KL64582-3237", "NQ65533-3236", "LH77257-3221"];
	//renderFileList();
  } else {
  // assume server may provide /tic-id.json (array of strings)
  console.log(`tryFetchTicIdList: Fetch file ${ticIdName}`);
  fetch(ticIdName).then(rTicId=>{
    console.log(`tryFetchTicIdList: rTicId.ok=${rTicId.ok}`);
    if(!rTicID.ok) throw new Error('no TicId-list');
    return rTicId.json();
  }).then(list=>{
    console.log('tryFetchTicIdList: check list to see if array');
    if(Array.isArray(list)){
      state.ticId = list;
	  console.log(`tryFetchTicIdList: list array size is ${list.length}`);
      //renderFileList();
    }
  }).catch(err=>{
    // fallback: show input only; update message
    //const fl = qs('#file-list');
    //fl.innerHTML = `<div class="small-muted">No /csv-list.json available (or fetch failed). Use paste or local-file below.</div>`;
	console.log(`tryFetchTicIdList: ERROR: error retrieving ${ticIdName} file`);
  });
  }
}

// ----------------- CSV file list attempt -----------------
function tryFetchCsvList(){
 console.log('tryFetchCsvList:');
 let jsonName = 'csv-list.json';
 if ( fullUrl.toLowerCase().startsWith("http") && fullUrl.toLowerCase().includes("/workspace/") ) {
		// looks like we are using the workspace sever so set name 
		jsonName = '/workspace/csv-list.json';
	}
 if ( fullUrl.toLowerCase().startsWith("file:") ) {
	// if we loaded html from a file the CORS policy won't allow local file access
	// so we'll just simulate a list for demo purposes and render files list
	console.log('Simulating JSON file retrieval for demo purpose');
	state.availableFiles = ['workorders.csv'];
	renderFileList();
  } else {
  // assume server may provide /csv-list.json (array of strings)
  console.log(`tryFetchCsvList: Fetch file ${jsonName}`);
  fetch(jsonName).then(r=>{
    console.log(`r.ok=${r.ok}`);
    if(!r.ok) throw new Error('no csv-list');
    return r.json();
  }).then(list=>{
    console.log('tryFetchCsvList: check list to see if array');
    if(Array.isArray(list)){
      state.availableFiles = list;
      renderFileList();
    }
  }).catch(err=>{
    // fallback: show input only; update message
    const fl = qs('#file-list');
    fl.innerHTML = `<div class="small-muted">No /csv-list.json available (or fetch failed). Use paste or local-file below.</div>`;
  });
  }
}

function renderFileList() {
  const fl = qs('#file-list');
  if (!state.availableFiles || state.availableFiles.length === 0) {
    fl.innerHTML = `<div class="small-muted">No files found in /csv-list.json</div>`;
    return;
  }
  fl.innerHTML = '';
  state.availableFiles.forEach(fname => {
    const el = document.createElement('div');
    el.classList.add('file-item');
	el.dataset.file = fname;
	console.log(`fname=${fname}`);
    el.innerHTML = `${escapeHtml(fname)}`;

    // Add the click event listener here
    el.addEventListener('click', (event) => {
      const selectedFile = event.target.dataset.file;
      console.log(`Loading file: ${selectedFile}`);
      tryAutoLoadTable(selectedFile);
    });

    fl.appendChild(el);
  });
}

// ----------------- Loading CSV -----------------
function tryAutoLoadTable(tableParam){
  // try several patterns:
  const attempts = [];
  if(tableParam.startsWith('http://') || tableParam.startsWith('https://') || tableParam.startsWith('/')){
    attempts.push(tableParam);
  } else {
    attempts.push(tableParam); // maybe includes .csv
    attempts.push(ensureCsvExt(tableParam));
    // also try with leading / if necessary
    attempts.push('/' + ensureCsvExt(tableParam));
  }
  // attempt fetch sequentially until one ok
  (async function trySequential(idx=0){
    if(idx >= attempts.length){
      // no success; leave UI able to paste or select file
      qs('#csv-loaded').textContent = 'none';
      return;
    }
    const url = attempts[idx];
    try {
      const res = await fetch(url);
      if(!res.ok) throw new Error('fetch failed ' + res.status);
      const text = await res.text();
      state.csvUrl = url;
      state.rawText = text;
      processCsvText(text, url);
      return;
    } catch(e){
      // try next
      trySequential(idx+1);
    }
  })();
}

function loadCsvFromUrl(url){
  // allow plain filename (relative) or absolute url
  const tryUrl = (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('/')) ? url : ensureCsvExt(url);
  fetch(tryUrl).then(async r=>{
    if(!r.ok) throw new Error('fetch failed');
    const text = await r.text();
    state.csvUrl = tryUrl;
    state.rawText = text;
    processCsvText(text, tryUrl);
  }).catch(err=>{
    alert('Failed to fetch CSV: ' + err.message + '. If this is a local file, use the file chooser instead.');
  });
}

function processCsvText(text, sourceLabel){
  try {
    const rows = parseCSV(text);
    if(!rows || rows.length === 0) {
      alert('CSV contains no rows');
      return;
    }
    // header
    //const header = rows[0].map(h=>h.trim());
	//KC - changed this code to correct duplicate column header values
	const header = rows[0].reduce((acc, currentHeader) => {
		// Trim whitespace from the current header
		const trimmedHeader = currentHeader.trim();
		// Check for duplicates
		let newHeader = trimmedHeader;
		let count = 1;
		while (acc.includes(newHeader)) {
			newHeader = `${trimmedHeader}_${count}`;
			count++;
		}
		// Add the unique header to the new array
		acc.push(newHeader);
		return acc;
	}, []);
    state.header = header;
	let summaryTable = state.header.includes("Open/Closed") && state.header.includes("Status");
    // build rows as arrays, starting from index 1
    const dataRows = rows.slice(1).map(r => {
      // ensure length matches header (pad with '')
      const arr = header.map((_,i)=> r[i] !== undefined ? r[i] : '');
      return arr;
    });
    state.rows = dataRows;
    // detect date-like columns and convert to ISO where possible
    state.dateColumns = new Set();
    const headerIndexMap = {};
    header.forEach((h,i)=> headerIndexMap[h] = i);
    // examine each column for date pattern mm/dd/yyyy in at least one non-empty cell
    header.forEach((h,i)=>{
      for(const row of dataRows){
	    //console.log('examine date');
        const v = row[i];
        if(v && mmddyyyy_to_iso(v) ) {
          state.dateColumns.add(h);
		  //console.log('processCsvText:  state.dateColumns=(', state.dateColumns, ')');
          break;
        }
      }
    });
    // add __parsed array to every row for faster comparisons: for date columns convert to ISO, else store raw trimmed
    state.parsedRows = dataRows.map(arr => {
      const p = arr.map((cell, idx)=>{
        const colName = header[idx];
		//console.log(`'processCsvText:  colName=${colName}  state.dateColumns=(${state.dateColumns})`);
        if(state.dateColumns.has(colName)){
          const iso = mmddyyyy_to_iso(cell);
		  //console.log(`colName=${colName}  cell=${cell}   iso=${iso}`);
          return iso || (cell ? cell.trim() : '');
        } else {
          return (cell != null) ? cell.trim() : '';
        }
      });
      const obj = arr.slice(); // keep original arr for display
      obj.__parsed = p;
      return obj;
    });

    // default visible columns to all (first time only)
    if(!state.visibleColumns || state.visibleColumns.length === 0 || state.visibleColumns.length !== header.length){
      state.visibleColumns = [...header];
    }
    qs('#csv-loaded').textContent = sourceLabel || 'loaded';
    qs('#table-title').scrollIntoView({behavior:'smooth', block:'start'});
    renderControls();
    renderTable();
  } catch(e){
    alert('Error parsing CSV: ' + e.message);
    console.error(e);
  }
}

// ----------------- Render Controls -----------------
function renderControls(){
  renderFileList(); // if availableFiles
  // columns list
  const colList = qs('#columns-list');
  colList.innerHTML = '';
  if(!state.header || state.header.length === 0){
    colList.innerHTML = '<div class="small-muted">No CSV loaded yet.</div>';
  } else {
    state.header.forEach(h=>{
      const id = 'colchk-' + h.replace(/\s+/g,'_');
      const div = document.createElement('div');
      div.className = 'inline-row';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.className = 'col-checkbox';
      input.id = id;
      input.dataset.col = h;
      input.checked = state.visibleColumns.includes(h);
      input.addEventListener('change', ()=> {
        // update state.visibleColumns
        const checkedBoxes = qsa('.col-checkbox').filter(cb=>cb.checked).map(cb=>cb.dataset.col);
        state.visibleColumns = checkedBoxes;
      });
      const label = document.createElement('label');
      label.htmlFor = id;
      label.style.flex='1';
      label.innerHTML = '<strong>' + escapeHtml(h) + '</strong>' + (state.dateColumns.has(h) ? ' <span class="small-muted">(date yyyy/mm/dd)</span>' : '');
      div.appendChild(input);
      div.appendChild(label);
      colList.appendChild(div);
    });
  }
  // sorts
  const sortList = qs('#sort-list');
  sortList.innerHTML = '';
  if(!state.sorts || state.sorts.length === 0){
    sortList.innerHTML = '<div class="small-muted">No sorts defined.</div>';
  } else {
    state.sorts.forEach(s => {
      sortList.appendChild(makeSortRowElement(s));
    });
  }
  // searches
  const searchList = qs('#search-list');
  searchList.innerHTML = '';
  if(!state.searches || state.searches.length === 0){
    searchList.innerHTML = '<div class="small-muted">No searches defined.</div>';
  } else {
    state.searches.forEach(s => {
      searchList.appendChild(makeSearchRowElement(s));
    });
  }
  // ensure select-all checkbox reflects if all visible
  const allChecked = state.header && state.header.length && state.visibleColumns.length === state.header.length;
  qs('#select-all-cols').checked = Boolean(allChecked);
}

function makeSortRowElement(s){
  const wrapper = document.createElement('div');
  wrapper.className = 'row-actions';
  wrapper.style.marginBottom='6px';
  wrapper.style.alignItems='center';
  // select column
  const colSel = document.createElement('select');
  state.header.forEach(h => {
    const o = document.createElement('option');
    o.value = h;
    o.textContent = h + (state.dateColumns.has(h) ? ' (date yyyy/mm/dd)' : '');
    if(h === s.col) o.selected = true;
    colSel.appendChild(o);
  });
  colSel.addEventListener('change', ()=> { s.col = colSel.value; });

  // direction select
  const dirSel = document.createElement('select');
  ['asc','desc'].forEach(d=>{
    const o = document.createElement('option'); o.value = d; o.textContent = d.toUpperCase(); if(d===s.dir) o.selected=true; dirSel.appendChild(o);
  });
  dirSel.addEventListener('change', ()=> { s.dir = dirSel.value; });

  // delete button
  const del = document.createElement('button'); del.className='small ghost'; del.textContent='Delete';
  del.addEventListener('click', ()=> {
    state.sorts = state.sorts.filter(x=>x.id !== s.id);
    renderControls();
  });

  wrapper.appendChild(colSel);
  wrapper.appendChild(dirSel);
  wrapper.appendChild(del);
  return wrapper;
}

// Function to update the operator dropdown based on the selected column
const updateOperators = (columnName, operatorSelectElement) => {
    // Determine the type of the column.

    // Clear the current options from the dropdown
    operatorSelectElement.innerHTML = '';

    // Repopulate the dropdown with new options
	getOpsForCol(columnName).forEach(op=>{
		let o = document.createElement("option");
		o.value = op; 
		o.textContent = op;
		operatorSelectElement.appendChild(o);
	});	
};

function makeSearchRowElement(s){
  const wrapper = document.createElement('div');
  wrapper.className = 'row-actions';
  wrapper.style.marginBottom='6px';
  wrapper.style.alignItems='center';
  // column select
  const colSel = document.createElement('select');
  state.header.forEach(h => {
    const o = document.createElement('option');
    o.value = h;
    o.textContent = h + (state.dateColumns.has(h) ? ' (date yyyy/mm/dd)' : '');
    if(h === s.col) o.selected = true;
    colSel.appendChild(o);
  });
  colSel.addEventListener('change', ()=>{
    s.col = colSel.value;
    // when column changes we might want to convert value? leave as is and let user edit
	updateOperators(s.col, opSel);
    // You might also want to reset the operator and search value here
    s.op = opSel.value;
  });

  // operator? For simplicity we'll only do "contains" for text and exact for date-ish if user types full ISO.
  let opSel=document.createElement("select");
  // Populate with initial operators based on the first selected column
  updateOperators(s.col, opSel);

  opSel.addEventListener('change', ()=>{
    s.op = opSel.value;
  });	
	
  // collect value to seach for...
  const valInput = document.createElement('input');
  valInput.type = 'text';
  valInput.placeholder = state.dateColumns.has(s.col) ? 'YYYY-MM-DD or partial (e.g. 2023-05)' : 'contains...';
  valInput.value = s.value || '';
  valInput.addEventListener('input', ()=> { s.value = valInput.value; });

  // delete
  const del = document.createElement('button'); del.className='small ghost'; del.textContent='Delete';
  del.addEventListener('click', ()=>{
    state.searches = state.searches.filter(x=>x.id !== s.id);
    renderControls();
  });

  wrapper.appendChild(colSel);
  wrapper.appendChild(opSel);
  wrapper.appendChild(valInput);
  wrapper.appendChild(del);
  return wrapper;
}

function getOpsForCol(col){
  //console.log(`col=${col}  state.dateColumns=${state.dateColumns}`);
  if(state.dateColumns.has(col)){
    return ["equals","before","after","on or before","on or after","contains"];
  }
  return ["contains","equals","starts with","ends with",">","<",">=","<="];
}

function addSortControl(){
  const id = 'sort-' + Date.now() + '-' + Math.floor(Math.random()*1000);
  const defaultCol = (state.header && state.header[0]) || '';
  const newSort = { id, col: defaultCol, dir: 'asc' };
  state.sorts.push(newSort);
  renderControls();
}

function addSearchControl(){
  if(!state.header || state.header.length === 0) return;
  const id = 'search-' + Date.now() + '-' + Math.floor(Math.random()*1000);
  const defaultCol = state.header[0];
  const newSearch = { id, col: defaultCol, value: '' };
  state.searches.push(newSearch);
  renderControls();
}

// ----------------- Apply Changes & Render Table -----------------
function applyChanges(){
  // update state.visibleColumns from checkboxes
  const checked = qsa('.col-checkbox').filter(cb => cb.checked).map(cb => cb.dataset.col);
  state.visibleColumns = checked;
  // ensure sorts/searches reflect current controls (they already update on change)
  renderTable();
}

function openWorkOrderPopup(ticString, idString) {
  // Check if the passed in string is a valid value
  if (!ticString || typeof ticString !== 'string') {
    console.error("Error: openWorkOrderPopup: A valid string ID for Ticket # must be provided.");
    return;
  }
  let url = "";
  if (!idString || typeof idString !== 'string' || idString == '0') {
		// Construct the full URL with the provided ID to PRINT work order
		url = `https://www.avalon-estates.com/admin2/requestmanager/print_wo.php?id=${ticString}`;
	} else {
		url = `https://www.avalon-estates.com/forms/?view=staffedit&id=${idString}&tic=${ticString}`;
  }   
  //console.log(`url="${url}"`);
  // Define window features (size, scrollbars, etc.)
  const windowFeatures = "width=600,height=600,scrollbars=yes,resizable=yes,left=10,top=10";
  // Open the new popup window
  window.open(url, '_blank', windowFeatures);
}

function postToMainTable(ocIndex, sIndex) {
    const tableContainer = document.getElementById('report-table');
    tableContainer.innerHTML = '';

    const mainTable = document.createElement('table');
    let tableHTML = `
        <thead>
            <tr><th>Open/Closed</th><th>Status</th><th>Count</th></tr>
        </thead>
        <tbody>
		<tr><td>Open/Closed Index</td><td>${ocIndex}</td></tr>
		<tr><td>Status Index</td><td>${sIndex}</td></tr>
    `;
	tableHTML += `</tbody>`;
    mainTable.innerHTML = tableHTML;
    tableContainer.appendChild(mainTable);
}

function processSummary(ocIndex, sIndex, data) {
	if (ocIndex === -1 || sIndex === -1) {
        //alert("CSV must contain 'Open/Closed' and 'Status' columns.");
		const tableContainer = document.getElementById('report-table');
		tableContainer.innerHTML = '<h4>4) Work Order Summary for CSV File</h4><p class="small-note">CSV file must contain "Open/Closed" and "Status" columns to create a summary.';
        return;
    }
    const pivotCounts = {};
    data.forEach(row => {
        const openClosedValue = row[ocIndex];
        const statusValue = row[sIndex];
        if (openClosedValue) {
            if (!pivotCounts[openClosedValue]) {
                pivotCounts[openClosedValue] = { total: 0, breakdown: {} };
            }
            pivotCounts[openClosedValue].total++;
            if (statusValue) {
                pivotCounts[openClosedValue].breakdown[statusValue] = (pivotCounts[openClosedValue].breakdown[statusValue] || 0) + 1;
            } else {
                const noStatusKey = "N/A";
                pivotCounts[openClosedValue].breakdown[noStatusKey] = (pivotCounts[openClosedValue].breakdown[noStatusKey] || 0) + 1;
            }
        }
    });

    const tableContainer = document.getElementById('report-table');
    tableContainer.innerHTML = '<h4>4) Work Order Summary for CSV File</h4>';
    const mainTable = document.createElement('table');
	mainTable.className = 'table-style-RT';
    let tableHTML = `
		<colgroup>
			<col style="width: 20%;"> <col style="width: 60%;"> <col> <col style="width: 20%; text-align:center;">
        <thead>
            <tr><th>Open/Closed</th><th>Status</th><th class="align-center">Count</th></tr>
        </thead>
        <tbody>
    `;
    Object.entries(pivotCounts).forEach(([openClosed, counts]) => {
        const breakdownEntries = Object.entries(counts.breakdown);       
        tableHTML += `
            <tr>
                <td>${openClosed}</td>
                <td>Total</td>
                <td class="align-center">${counts.total}</td>
            </tr>
        `;       
        if (breakdownEntries.length > 0) {
            breakdownEntries.forEach(([status, count]) => {
                tableHTML += `
                    <tr>
                        <td></td>
                        <td>${status}</td>
                        <td class="align-center">${count}</td>
                    </tr>
                `;
            });
        }
    });
    tableHTML += `</tbody>`;
    mainTable.innerHTML = tableHTML;
    tableContainer.appendChild(mainTable);
}



function renderTable(){
  //console.log ("starting renderTable() function");
  const container = qs('#table-container');
  container.innerHTML = '';
  if(!state.header || state.header.length === 0){
    container.innerHTML = '<div class="no-data">No CSV loaded yet.</div>';
    return;
  }
  const openClosedIndex = state.header.indexOf('Open/Closed');
  const statusIndex = state.header.indexOf('Status');  
  // Start with parsedRows
  let rows = state.parsedRows.slice();
  // Process rows to produce a summary of the CSV file of work Orders
  processSummary(openClosedIndex, statusIndex, rows);
  //console.log ("starting to apply searches");
  // Apply searches (AND)
  if(state.searches && state.searches.length > 0){
    //console.log ("starting to apply search criteria");
    rows = rows.filter(rowArr => {
      return state.searches.every(s => {
	    //console.log("s.col(", s.col, ")  s.op(", s.op, ")  s.value(", s.value, ")"); 
        const col = s.col;
        const idx = state.header.indexOf(col);
        if(idx === -1) return true; // no such column -> ignore
        const cellParsed = rowArr.__parsed[idx] !== undefined ? rowArr.__parsed[idx] : (rowArr[idx] || '');
        const filterValRaw = (s.value || '').trim();
        if(filterValRaw === '') return true; // empty filter -> pass
        if(state.dateColumns.has(col)){
		  //console.log ("starting to apply search criteria: In the date section: for column '", col, "'");
          // convert filterVal if user typed mm/dd/yyyy or yyyy-mm-dd etc
          let filterIso = null;
          if(/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(filterValRaw)){
            filterIso = mmddyyyy_to_iso(filterValRaw);
          } else if(/^\d{4}-\d{2}-\d{2}$/.test(filterValRaw)){
            filterIso = filterValRaw;
          } else {
            // allow partial match like '2023-05'
            filterIso = filterValRaw;
          }
          if(!cellParsed) return false;
          // both are strings; use contains for partial filter
          //return String(cellParsed).indexOf(filterIso) !== -1;
		  //KC - changed this code to allow for multiple search operators
		  //console.log ("starting to apply search criteria: In the date section: cellParsed(", cellParsed, "), operation(", s.op, ") filterIso(", filterIso, ")");
		  switch(s.op){
			case "equals": return cellParsed==filterIso;
			case "contains": return cellParsed.toString().includes(filterIso);
			case "before": return cellParsed<filterIso;
			case "after": return cellParsed>filterIso;
			case "on or before": return cellParsed<=filterIso;
			case "on or after": return cellParsed>=filterIso;
			default: return true;
		  }		  
        } else {
          const lcCell = (cellParsed || '').toString().toLowerCase();
          const lcFilter = filterValRaw.toLowerCase();
          //return lcCell.indexOf(lcFilter) !== -1;
		  //console.log ("starting to apply search criteria: In the NON date section: lcell(", lcCell, "), operation(", s.op, ") lcfilter(", lcFilter, ")");
		  switch(s.op){
			case "equals": return lcCell==lcFilter;
			case "contains": return lcCell.toString().includes(lcFilter);
			case "before": return lcCell<lcFilter;
			case "after": return lcCell>lcFilter;
			case "on or before": return lcCell<=lcFilter;
			case "on or after": return lcCell>=lcFilter;
		    case ">": return parseFloat(lcCell)>parseFloat(lcFilter);
			case "<": return parseFloat(lcCell)<parseFloat(lcFilter);
			case ">=": return parseFloat(lcCell)>=parseFloat(lcFilter);
			case "<=": return parseFloat(lcCell)<=parseFloat(lcFilter);	
			default: return true;
		  }
        }
      });
    });
  }

  // Apply sorts
  if(state.sorts && state.sorts.length > 0){
    // build columnIndexMap
    const columnIndexMap = {};
    state.header.forEach((h,i)=> columnIndexMap[h]=i);
    const comp = makeComparator(state.sorts, columnIndexMap, state.dateColumns);
    rows.sort(comp);
  }

  // Build table DOM
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const thr = document.createElement('tr');
  // display header names in visibleColumns
  state.visibleColumns.forEach(colName=>{
    const th = document.createElement('th');
    th.className = 'sticky';
    th.innerHTML = '<strong>' + escapeHtml(colName) + '</strong>' + (state.dateColumns.has(colName) ? ' <span class="small-muted">(date yyyy/mm/dd)</span>' : '');
    thr.appendChild(th);
  });
  thead.appendChild(thr);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  if(rows.length === 0){
    const tr = document.createElement('tr');
    const td = document.createElement('td');
    td.colSpan = Math.max(1, state.visibleColumns.length);
    td.className = 'no-data';
    td.textContent = 'No rows match the current search filters.';
    tr.appendChild(td);
    tbody.appendChild(tr);
  } else {
    rows.forEach(rowArr => {
      const tr = document.createElement('tr');
      state.visibleColumns.forEach(colName=>{
        const idx = state.header.indexOf(colName);
        let displayVal = rowArr.__parsed && rowArr.__parsed[idx] !== undefined ? rowArr.__parsed[idx] : (rowArr[idx] || '');
        // For date columns, ensure we display yyyy-mm-dd if possible (we parsed earlier)
        if(state.dateColumns.has(colName)){
          // if stored as ISO already, show that; else if original had mm/dd/yyyy convert now for display
          if(!displayVal && rowArr[idx]) {
            const iso = mmddyyyy_to_iso(rowArr[idx]);
            if(iso) displayVal = iso;
            else displayVal = rowArr[idx];
          }
        }
        const td = document.createElement('td');
		//td.innerHTML = escapeHtml(displayVal == null ? '' : String(displayVal));
		if("Ticket" == colName || "Ticket #" == colName){
		// Create the cell and a string to pass
			const workOrderID = displayVal;
			let ticketId = "0";
			ticAndId = state.ticId.find(entry => entry.substring(0, 7) === workOrderID);
			console.log(`workOrderID=${workOrderID}  ticAndId=${ticAndId}`);
			const link = document.createElement('a');
			if (ticAndId === undefined ) { 
				ticketId = "0";
			  } else {
				let parts = ticAndId.split("-");
				ticketId = parts[1];
				// Change the color to green
				link.style.color = 'green';
			}
			link.textContent = workOrderID;
			link.href = `#`; // Use '#' to make it clickable without navigating away
			// Add the click event listener to the link
			link.addEventListener('click', function(event) {
				// Prevent the default link behavior (navigating to '#')
				event.preventDefault();  
				// Call your popup function with the ID			
				openWorkOrderPopup(workOrderID, ticketId);
			});
			// Append the link to the cell
			td.appendChild(link);
         } else {
		   // link to view/edit ticket https://www.avalon-estates.com/forms/?view=useredit&id=2775&tic=NQ88565
           if ("Link" == colName || "href" == colName){
              	td.innerHTML = "<a href='" + displayVal + "'  target='_blank'>Edit Ticket</a>";	   
			  } else {		
				td.innerHTML = escapeHtml(displayVal == null ? '' : String(displayVal));
			}
		}
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }

  table.appendChild(tbody);
  container.appendChild(table);

  // Update header title with current table param/csv
  const displayName = state.csvUrl || state.tableParam;
  qs('#table-name').textContent = state.tableParam;
  qs('#csv-loaded').textContent = displayName;
}

// ----------------- Init convenience: if header exists re-render -----------------
window.addEventListener('resize', ()=>{/* noop */});
</script>

</body>
</html>