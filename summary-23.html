<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Summary Tool (Pivot-like) — Responsive Controls</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; font-size: 14px; color: #222; }
    h2 { margin: 0 0 10px 0; }

	table { border-collapse: collapse; margin: 10px 0; display: inline-table; }
	th, td { border: 1px solid #aaa; padding: 8px; text-align: center; vertical-align: top; }
    th { background-color: #f0f0f0; font-weight: 600; }
    td { vertical-align: top; }

    #controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(200px, 1fr));
      gap: 10px;
      background: #f3f3f3;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 12px;
      align-items: start;
    }
    @media (max-width: 780px) {
      #controls { grid-template-columns: 1fr; }
    }
    #controls section {
      background: #fff;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-height: 56px;
      box-sizing: border-box;
	  max-width: 100%;
	  overflow: hidden;
    }
    label { font-size: 13px; }
    input[type="file"] { font-size: 13px; }
    input[type="text"], select { font-size: 13px; padding: 6px; box-sizing: border-box; }
    select { min-height: 36px; }

    .summary-row { display:flex; gap:8px; align-items:flex-start; }
    #summaryColumns { flex: 1 1 auto; min-height: 140px; max-height: 160px; width:100%; }
    .move-controls { display:flex; flex-direction: column; gap:6px; align-items: stretch; }

    button {
      padding: 6px 8px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 13px;
    }
    .btn-primary { background: #007BFF; color: #fff; }
    .btn-success { background: #28A745; color: #fff; }
    .btn-move { background: #17A2B8; color: #fff; min-width: 40px; }
    .btn-ghost { background: transparent; border: 1px solid #ddd; color: #333; }

    .filters-row { display:flex; gap:8px; flex-direction:column flex:1 }
	.filters-row > select,
	.filters-row > input { flex: 1 1 0; min-width: 20px;}
	.filters-row > button {  flex: 0 0 auto;}
	
	#multiFilters {  padding: 8px;  width: 100%;  box-sizing: border-box;}

  

    fieldset { border: 1px solid #ccc; padding: 6px; border-radius: 4px; font-size: 12px; display:flex; align-items:flex-start; gap:12px; flex-wrap:wrap; }
    legend { font-size: 12px; padding: 0 4px; }

    .year-filters { display:flex; gap:8px; flex-wrap:wrap; }
	.address-filters { display:flex; gap:8px; flex-wrap:wrap; }

    .totals-row { font-weight: bold; background: #f9f9f9; }
	.help-box {
		display: none; /* Hide the help box by default */
		position: absolute; /* Position it relative to the nearest positioned ancestor */
		background-color: #f9f9f9; /* Background color */
		border: 1px solid #ccc; /* Border */
		border-radius:8px;
		padding: 10px; /* Padding */
		z-index: 1000; /* Ensure it appears above other elements */
	}
	.help-hover:hover + .help-box {
		display: block; /* Show the help box on hover */
	}
	.file-item {
		font-size: 12px; /* Corrected font size property */
		border-bottom: 1px dashed #eef2f6;
		cursor: pointer;
		color: blue;
	}
	.file-item:hover {
		/* Change color and/or other styles on hover */
		color: #004085; /* A darker blue for a subtle change */
		background-color: #f0f0f0;
		border-bottom: 1px dashed #004085; /* Change border color on hover */
	}
	@media print {
    /* Set the body and HTML to have zero margin/padding to prevent blank pages */
    html, body {
        margin: 0;
        padding: 0;
    }
    
    /* Ensure the table header repeats on every page */
    #summaryTable table thead {
        display: table-header-group; /* This is the key property */
    }
    
    /* Ensure the table is properly structured for page breaks */
    #summaryTable table {
        border-collapse: collapse;
        /* Optional: Add a small top margin to prevent headers from touching the edge */
        margin-top: 10px; 
    }
    
    /* Standard CSS to hide page elements that shouldn't print (like buttons) */
    .no-print {
        display: none !important;
    }
	}	
	
  </style>
</head>
<body>

<h2>CSV Summary Tool (23.1)</h2>

<div id="controls">
  <!-- Column 1: File -->
  <section> 
	<h4 class="help-hover">CSV files (available on Server)</h4>
	<div class="help-box">If your server provides a file,<br>
						  csv-list.json (array of filenames),<br>
						  the file names will be show here.<br>
						  Otherwise use the 'Choose file'
						  <br> to display a local file.</div>
      <div class="file-list" id="file-list">
        <div class="muted small-note">Trying to fetch /csv-list.json for available files...</div>
      </div>
  						  
    <!--<label><strong>Choose File</strong></label>-->
	<h4>Choose Local File</h4>
    <input type="file" id="csvFile" accept=".csv" />
	<label><strong>Download current work orders into CSV File</strong></label>
    <button class="btn-primary" 
      onclick="window.open('https://www.avalon-estates.com/admin2/requestmanager/export.php?act=export&category=1&status=0&staffid=&begin=01%2F01%2F2025&end=&submit=Submit', '_blank');">
      Download Latest 2025 Work Orders
    </button>
	<button class="btn-primary" 
      onclick="window.open('https://www.avalon-estates.com/admin2/requestmanager/export.php?act=export&category=1&status=0&staffid=&begin=&end=&submit=Submit', '_blank');">
      Download All Work Orders
    </button>
  </section>

<!-- Column 2: Summary -->
<section>
  <label><strong>Summary Columns (select columns to display)</strong></label>
  <div style="display:flex; gap:10px;">
    <!-- Left: all columns -->
    <select id="allColumns" multiple size="8" style="flex:1;"></select>

    <!-- Middle: move buttons -->
    <div class="move-controls" style="justify-content:center;">
      <button type="button" class="btn-move" onclick="moveSelected('allColumns','summaryColumns')">→</button>
      <button type="button" class="btn-move" onclick="moveSelected('summaryColumns','allColumns')">←</button>
    </div>

    <!-- Right: chosen columns -->
    <div style="display:flex; flex-direction:column; gap:6px; flex:1;">
      <select id="summaryColumns" multiple size="8" style="flex:1;"></select>
      <div style="display:flex; gap:6px; justify-content:center;">
        <button type="button" class="btn-move" onclick="moveOption('up')">▲</button>
        <button type="button" class="btn-move" onclick="moveOption('down')">▼</button>
      </div>
    </div>
  </div>
</section>

<!-- Column 3: Filters -->
<section>
  <label><strong>Filters (up to 4)</strong></label>
  <div id="multiFilters"></div>
  <button type="button" class="btn-ghost" onclick="addFilterRow()">+ Add Filter</button>

  <label><strong>Date Column</strong></label>
  <select id="dateColumn" onchange="populateYearCheckboxes()"></select>

  <fieldset>
    <legend>Grouping</legend>
    <label><input type="radio" name="groupMode" value="none" checked> None</label>
    <label><input type="radio" name="groupMode" value="age"> Age (&lt;30 / 30+)</label>
	<label><input type="radio" name="groupMode" value="age30+"> Age (30+ only)</label>
    <label><input type="radio" name="groupMode" value="month"> Monthly</label>
    <label><input type="radio" name="groupMode" value="year"> Yearly</label>
    <div class="address-filters" id="addressFilters"></div>
	<div class="year-filters" id="yearFilters"></div>
  </fieldset>

  <div style="display:flex; gap:8px; margin-top:6px;">
    <button class="btn-success" onclick="generateSummary()">Generate</button>
    <button class="btn-primary" onclick="downloadCSV()">Download Summary to CSV</button>
	<button class="btn-primary" onclick="printTable()">Print Table</button>
  </div>
</section>

</div>

<h3>Summary Output:</h3>
<div id="summaryTable"></div>

<script>

let csvData = [], headers = [], ticId = [], availableFiles = [];
// Get the full URL of this execution for any queries in the javascript
console.log(`summary-23.html  version 23.1`);
let fullUrl = window.location.href;
console.log(`The full URL is: ${fullUrl}`);
// Get just the URL path
let urlPath = window.location.pathname;
console.log(`The URL path is: ${urlPath}`);
let savedGroupMode = '';

// get json file that list csv files on server
tryFetchCsvList('summary-list.json');
//retrieve work order ticket number and ID
tryFetchTicIdList('tic-id.json');

function qs(sel, el=document) { return el.querySelector(sel); }

function moveSelected(fromId, toId) {
  const from = document.getElementById(fromId);
  const to = document.getElementById(toId);
  [...from.selectedOptions].forEach(opt => {
    to.appendChild(opt);
  });
}

function moveSelectedArray(fromId, toId, valuesArray) {
  const from = document.getElementById(fromId);
  const to = document.getElementById(toId);

  // Step 1: Move everything from 'to' back to 'from'
  [...to.options].forEach(opt => {
    from.appendChild(opt);
  });

  // Step 2: Clear selection in 'from'
  [...from.options].forEach(opt => {
    opt.selected = false;
  });

  // Step 3: Select matching values in 'from' and move to 'to'
  valuesArray.forEach(value => {
    const match = [...from.options].find(opt => opt.value === value);
    if (match) {
      match.selected = true;
	  [...from.selectedOptions].forEach(opt => {
        to.appendChild(opt);
      });
    }
  });
}

//KC <input type="text" class="filterValue" placeholder="Value (contains)">
//   <select class="filterColumn"></select>
//   <input type="text" class="filterValue" >
function addFilterRow() {
  const container = document.getElementById('multiFilters');
  if (container.children.length >= 4) return; // max 4
  const div = document.createElement('div');
  div.className = 'filters-row';
  div.innerHTML = `
    <select class="filterColumn"></select>
    <input type="text" class="filterValue" >
    <button type="button" class="btn-ghost" onclick="this.parentElement.remove()">✖</button>
  `;
  container.appendChild(div);

  // populate select options with headers
  headers.forEach(c => {
    const o = document.createElement("option");
    o.value = c; o.textContent = c;
    div.querySelector('.filterColumn').appendChild(o);
  });
}

function clearAllFilters(containerId = 'multiFilters') {
  const container = document.getElementById(containerId);
  if (container) {
    container.innerHTML = '';
  }
}

function addSingleFilter(column, value ) {
  //const container = document.getElementById(containerId);
  const container = document.getElementById('multiFilters');
  const exist = headers.includes(column);
  if (!exist) value = '';
  
  const div = document.createElement('div');
  div.className = 'filters-row';
  div.innerHTML = `
    <select class="filterColumn"></select>
    <input type="text" class="filterValue" value="${value}">
    <button type="button" class="btn-ghost" onclick="this.parentElement.remove()">✖</button>
  `;
  container.appendChild(div);

  const select = div.querySelector('.filterColumn');
  headers.forEach(c => {
    const o = document.createElement("option");
    o.value = c;
    o.textContent = c;
    select.appendChild(o);
  });
  if (exist) select.value = column;
}

function getFilters() {
  const rows = [...document.querySelectorAll('#multiFilters .filters-row')];
  return rows.map(r => ({
    col: r.querySelector('.filterColumn').value,
    val: r.querySelector('.filterValue').value.trim().toLowerCase()
  })).filter(f => f.val); // only active ones
}

function parseCSV(csv, delimiter = ",") {
  const pattern = new RegExp(("(\\" + delimiter + "|\\r?\\n|\\r|^)" +
    "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" + "([^\"\\" + delimiter + "\\r\\n]*))"), "gi");
  const rows = [[]];
  let matches;
  while ((matches = pattern.exec(csv))) {
    const matchedDelimiter = matches[1];
    if (matchedDelimiter.length && matchedDelimiter !== delimiter) rows.push([]);
    let value = matches[2] ? matches[2].replace(/""/g, '"') : matches[3];
    rows[rows.length - 1].push(value);
  }
  return rows.filter(row => row.length > 1 || (row.length === 1 && row[0] !== ""));
}

document.getElementById('csvFile').addEventListener('change', e => {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    //console.log(`file(${file})  ev.target.result(${ev.target.result})`);
    processCsv(ev.target.result);
  };
  reader.readAsText(file);
});

function processCsv(text) {
    const rows = parseCSV(text);
    const rawHeaders = rows[0].map(h => String(h || ""));
    headers = rawHeaders.map((h, i) => rawHeaders.indexOf(h) !== i ? `${h||'Column'}-${i}` : (h||`Column-${i}`));
	if (headers.includes('Address')) { headers.push('Street Name'); }
    csvData = rows.slice(1).map(row => {
      const obj = {}; 
	  headers.forEach((h,i)=>obj[h]=row[i]||""); 
	  // If "Address" exists, extract street name
	  if (obj["Address"]) {
		// Remove leading numbers and optional punctuation/spaces
		const streetName = obj["Address"].replace(/^\d+\s*/, "");
		obj["Street Name"] = streetName;
	   } else {
		obj["Street Name"] = ""; // fallback if Address is missing
	  }
	  return obj;
    });
	
    populateColumnSelectors(headers);
	populateAddressSelectors(headers);
  };

// ----------------- CSV file list attempt -----------------
function tryFetchCsvList(jsonName){
 console.log(`tryFetchCsvList: start`);
 if ( fullUrl.toLowerCase().startsWith("http") && fullUrl.toLowerCase().includes("/workspace/") ) {
		// looks like we are using the workspace sever so set name 
		jsonName = `/workspace/${jsonName}`;
	}
 if ( fullUrl.toLowerCase().startsWith("file:") ) {
	// if we loaded html from a file the CORS policy won't allow local file access
	// so we'll just simulate a list for demo purposes and render files list
	console.log('Simulating JSON file retrieval for demo purpose');
	availableFiles = ['workorders.csv', 'google-analytics-expanded.csv'];
	renderFileList();
  } else {
  // assume server may provide json file (array of strings)
  console.log(`tryFetchCsvList: Fetch file ${jsonName}`);
  fetch(jsonName, { cache: 'reload' }).then(r=>{
    if(!r.ok) throw new Error('no csv-list');
    return r.json();
  }).then(list=>{
    console.log('tryFetchCsvList: check list to see if array');
    if(Array.isArray(list)){
      availableFiles = list;
      renderFileList();
    }
  }).catch(err=>{
    // fallback: show input only; update message
    const fl = qs('#file-list');
    fl.innerHTML = `<div class="small-muted">No /csv-list.json available (or fetch failed). Use paste or local-file below.</div>`;
  });
  }
}

function renderFileList() {
  const fl = qs('#file-list');
  if (!availableFiles || availableFiles.length === 0) {
    fl.innerHTML = `<div class="small-muted">No files found in /csv-list.json</div>`;
    return;
  }
  fl.innerHTML = '';
  availableFiles.forEach(fname => {
    const el = document.createElement('div');
    el.classList.add('file-item');
	el.dataset.file = fname;
	console.log(`fname=${fname}`);
    el.innerHTML = `${fname}`;

    // Add the click event listener here
    el.addEventListener('click', (event) => {
      const selectedFile = event.target.dataset.file;
      console.log(`Loading file: ${selectedFile}`);
      tryFetchCsv(selectedFile);
    });

    fl.appendChild(el);
  });
}

// ----------------- Loading CSV -----------------
function tryFetchCsv(url){
	const csvName = url;
	if ( fullUrl.toLowerCase().startsWith("http") && fullUrl.toLowerCase().includes("/workspace/") ) {
		// looks like we are using the workspace sever so set name 
		cvsName = `/workspace/${csvName}`;
	}
	console.log(`tryFetchCsv: Fetch file ${csvName}`);
	fetch(csvName, { cache: 'reload' }).then(r=>{
		//console.log(`r.ok=${r.ok}`);
		if(!r.ok) throw new Error(`no file ${csvName}`);
		return r.text();
	}).then(text=>{
		processCsv(text);		
	}).catch(err=>{
		console.error('tryFetchCsv: Fetch error:', err)
		console.log(`tryFetchCsv: error retrieving ${url} file: ${err}`);
	});
}

// ----------------- Ticket ID file list attempt -----------------
function tryFetchTicIdList(jsonName){
 console.log(`tryFetchTicIdList:  file name ${jsonName}`);
 if ( fullUrl.toLowerCase().startsWith("http") && fullUrl.toLowerCase().includes("/workspace/") ) {
		// looks like we are using the workspace sever so set name 
		jsonName = `/workspace/${jsonName}`;
	}
 if ( fullUrl.toLowerCase().startsWith("file:") ) {
	// if we loaded html from a file the CORS policy won't allow local file access
	// so we'll just simulate a list for demo purposes and render files list
	console.log('Simulating JSON file retrieval for demo purpose');
	ticId = ["KL64582-3237", "NQ65533-3236", "LH77257-3221", "VX83546-3167"];
  } else {
  // assume server may provide /tic-id.json (array of strings)
  console.log(`tryFetchTicIdList: Fetch file ${jsonName}`);
  fetch(jsonName, { cache: 'reload' }).then(r=>{
    //console.log(`r.ok=${r.ok}`);
    if(!r.ok) throw new Error(`no file ${jsonName}`);
    return r.json();
  }).then(list=>{
    //console.log('tryFetchTicIdList: check list to see if array');
    if(Array.isArray(list)){
      ticId = list;
	  console.log(`tryFetchTicIdList: array size is ${list.length}`);
    }
  }).catch(err=>{
	console.error('tryFetchTicIdList: Fetch error:', err)
	console.log(`tryFetchTicIdList: error retrieving ${jsonName} file: ${err}`);
  });
  }
}

function populateColumnSelectors(cols) {
  ['allColumns','dateColumn'].forEach(id=>{
    const sel=document.getElementById(id); sel.innerHTML="";
    cols.forEach(c=>{
      const o=document.createElement("option"); o.value=c; o.textContent=c;
      sel.appendChild(o);
    });
  });

  // clear summaryColumns
  document.getElementById('summaryColumns').innerHTML="";

  if (cols.length) {
    document.getElementById('dateColumn').selectedIndex = 0;
    populateYearCheckboxes();
  }

  // reset filters
  document.getElementById('multiFilters').innerHTML="";
  addFilterRow();
}

function moveOption(dir) {
  const sel=document.getElementById("summaryColumns"), opts=[...sel.options];
  if(dir==="up"){
    for(let i=1;i<opts.length;i++){if(opts[i].selected&&!opts[i-1].selected){sel.insertBefore(opts[i],opts[i-1]);}}
  } else {
    for(let i=opts.length-2;i>=0;i--){if(opts[i].selected&&!opts[i+1].selected){sel.insertBefore(opts[i],opts[i+1].nextSibling);}}
  }
}
function selectAllSummary(){[...document.getElementById('summaryColumns').options].forEach(o=>o.selected=true);}
function clearSummary(){[...document.getElementById('summaryColumns').options].forEach(o=>o.selected=false);}

function populateYearCheckboxes() {
  const dateCol=document.getElementById("dateColumn").value, years=new Set();
  csvData.forEach(r=>{
    const d=new Date(r[dateCol]); if(!isNaN(d)) years.add(d.getFullYear());
  });
  const yDiv=document.getElementById("yearFilters"); yDiv.innerHTML="";
  [...years].sort().forEach(y=>{
    const lbl=document.createElement("label");
    lbl.innerHTML=`<input type="checkbox" value="${y}" checked> ${y}`;
    yDiv.appendChild(lbl);
  });
}

function populateAddressSelectors(cols) {
  console.log(`populateAddressSelectors`);
  if (cols.includes('Address')) {
	const aDiv=document.getElementById("addressFilters"); aDiv.innerHTML="";  
    const lbl=document.createElement("label");
    lbl.innerHTML = `<input type="checkbox" id="uniqueAddr" name="uniqueAddr">Only Unique Addresses`;
    aDiv.appendChild(lbl);
  } 
}

function generateSummary() {
  //update work order ticket number and ID in case they were updated	
  tryFetchTicIdList('tic-id.json');
  const groupMode=document.querySelector("input[name=groupMode]:checked").value;
  console.log(`savedGroupMode=${savedGroupMode}  groupMode=${groupMode}`);
  if(groupMode==="age30+" && savedGroupMode !== "age30+"){
		console.log(`summaryColumns length ${summaryColumns.length}`);
		if (summaryColumns.length < 1 ) {
			moveSelectedArray('allColumns','summaryColumns',[ 'Date','Ticket','Name','Assigned To','Status','Reason for Request' ]);	
		}
		clearAllFilters(); // Clears all filters
		addSingleFilter("Open/Closed", "open");
  }
  summaryCols=[...document.getElementById("summaryColumns").options].map(o=>o.value);
  if(!summaryCols.length){alert("Select summary columns");return;}
  console.log(summaryCols);
  const filters = getFilters();
  const dateCol=document.getElementById("dateColumn").value;
  //const groupMode=document.querySelector("input[name=groupMode]:checked").value;
  const selectedYears=[...document.querySelectorAll("#yearFilters input:checked")].map(cb=>parseInt(cb.value));
  const now=new Date(), summaryMap={};
  // --- New setup for unique address filter ---
  const uniqueAddr=document.querySelector("input[name=uniqueAddr]:checked");
  const addrIdx = headers.indexOf("Address");
  const seenAddrs = new Set();
  const uniqueStreet=document.querySelector("input[name=uniqueStreet]:checked");
  const seenstreet = new Set();
  let pass=true;

  csvData.forEach(row=>{
    // Step 1: Apply all filters
    pass=true;
    for(const f of filters){
      const cell=(row[f.col]||"").toLowerCase();
	  //console.log(`cell(${cell})`);
      if(!cell.includes(f.val)){ pass=false; break; }
    }
    if(!pass) return;

    // Step 2: Apply year filter
    if(selectedYears.length && dateCol){
      const d=new Date(row[dateCol]);
      if(!isNaN(d) && !selectedYears.includes(d.getFullYear())) return;
    }
	
	// --- Apply unique address filter ---
    if (uniqueAddr && addrIdx >= 0) {
      const addr = row[headers[addrIdx]];
      if (addr) {
        if (seenAddrs.has(addr)) return; // already processed, skip
        seenAddrs.add(addr);
      }
    }

    const keyParts=summaryCols.map(c=>row[c]||"Unknown"), comp=keyParts.join("|");
    let gk="Total";
	if(groupMode==="age30+"){
		const d=new Date(row[dateCol]);
		if(!isNaN(d)){
			const days=(now-d)/(1000*60*60*24);
			//gk=days>=30?"30+ Days":"Invalid Date";
			if (days<30) return;
			gk="30+ Days";
		}
	}
    if(groupMode==="age"){const d=new Date(row[dateCol]);if(!isNaN(d)){const days=(now-d)/(1000*60*60*24);gk=days>=30?"30+ Days":"<30 Days";} else gk="Invalid Date";}
    if(groupMode==="month"){const d=new Date(row[dateCol]); if(!isNaN(d)){gk=`${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;} else gk="Invalid Date";}
    if(groupMode==="year"){const d=new Date(row[dateCol]); if(!isNaN(d)){gk=`${d.getFullYear()}`;} else gk="Invalid Date";}
    if(!summaryMap[comp])summaryMap[comp]={keyParts,counts:{},total:0};
    summaryMap[comp].counts[gk]=(summaryMap[comp].counts[gk]||0)+1; summaryMap[comp].total++;
  });
  savedGroupMode = groupMode;
  renderSummaryTable(summaryMap,summaryCols,groupMode);
}

function openWorkOrderPopup(ticString, idString) {
  // Check if the passed in string is a valid value
  if (!ticString || typeof ticString !== 'string') {
    console.error("Error: openWorkOrderPopup: A valid string ID for Ticket # must be provided.");
    return;
  }
  let url = "";
  if (!idString || typeof idString !== 'string' || idString == '0') {
		// Construct the full URL with the provided ID to PRINT work order
		url = `https://www.avalon-estates.com/admin2/requestmanager/print_wo.php?id=${ticString}`;
	} else {
		url = `https://www.avalon-estates.com/forms/?view=staffedit&id=${idString}&tic=${ticString}`;
  }   
  //console.log(`url="${url}"`);
  // Define window features (size, scrollbars, etc.)
  const windowFeatures = "width=600,height=600,scrollbars=yes,resizable=yes,left=10,top=10";
  // Open the new popup window
  window.open(url, '_blank', windowFeatures);
}

function renderSummaryTable(summaryMap, summaryCols, groupMode) {
  // Collect all grouping keys
  let gks = new Set();
  Object.values(summaryMap).forEach(e => Object.keys(e.counts).forEach(k => gks.add(k)));
  gks = [...gks].sort();

  // Table header
  let html = "<table><tr>" + summaryCols.map(c => `<th>${c}</th>`).join("");
  if (groupMode !== "none") gks.forEach(g => html += `<th>${g}</th>`);
  html += "<th>Total</th></tr>";

  const entries = Object.values(summaryMap)
    .sort((a, b) => a.keyParts.join().localeCompare(b.keyParts.join()));

// Compute rowspans for pivot-style table
const rowspans = summaryCols.map(() => Array(entries.length).fill(1));

summaryCols.forEach((_, colIndex) => {
  let i = 0;
  while (i < entries.length) {
    let j = i + 1;

    // The inner loop must check two conditions:
    // 1. The current column value is the same (entries[i].keyParts[colIndex] === entries[j].keyParts[colIndex])
    // 2. ALL previous column values (from 0 to colIndex - 1) are also the same between row i and row j.
    while (
      j < entries.length && 
      entries[i].keyParts[colIndex] === entries[j].keyParts[colIndex] &&
      (colIndex === 0 || summaryCols.slice(0, colIndex).every((_, prevColIndex) => 
        entries[i].keyParts[prevColIndex] === entries[j].keyParts[prevColIndex]
      ))
    ) {
      j++;
    }

    // Assign the determined rowspan
    rowspans[colIndex][i] = j - i;
    
    // Set rowspan to 0 for the rows that are "consumed" by the rowspan
    for (let k = i + 1; k < j; k++) {
      rowspans[colIndex][k] = 0;
    }
    
    // Move to the next block
    i = j;
  }
});

  // Initialize totals
  const totals = { total: 0 };
  gks.forEach(g => totals[g] = 0);

  // Render table rows
  entries.forEach((entry, rowIndex) => {
    html += "<tr>";
    summaryCols.forEach((_, colIndex) => {
      if (rowspans[colIndex][rowIndex] > 0) {
        let cellValue = entry.keyParts[colIndex];

        // Ticket clickable
        if (/^ticket$/i.test(summaryCols[colIndex])) {
          const safeVal = cellValue.replace(/'/g, "\\'");
		  let ticketId = "0";
		  ticAndId = ticId.find(entry => entry.substring(0, 7) === safeVal);
		  if (ticAndId === undefined ) { 
				ticketId = "0";
				cellValue = `<a href="javascript:void(0)" onclick="openWorkOrderPopup('${safeVal}','${ticketId}')"><span style="color:blue;">${safeVal}</span></a>`;
			  } else {
				let parts = ticAndId.split("-");
				ticketId = parts[1];
				//console.log(`safeVal=${safeVal}  ticketId=${ticketId}`);
				// Change the color to green
				cellValue = `<a href="javascript:void(0)" onclick="openWorkOrderPopup('${safeVal}','${ticketId}')"><span style="color:green">${safeVal}</span></a>`;
		  }          
        } else {
          //cellValue = escapeHtml(cellValue);
        }
		//console.log(cellValue);
        html += `<td rowspan="${rowspans[colIndex][rowIndex]}">${cellValue}</td>`;
		//html += `<td rowspan="1">${cellValue}</td>`;
      }
    });

    if (groupMode !== "none") {
      gks.forEach(g => {
        const v = entry.counts[g] || 0;
        totals[g] += v;
        html += `<td>${v}</td>`;
      });
    }

    html += `<td>${entry.total}</td></tr>`;
    totals.total += entry.total;
	//console.log(`${html}`);
  });

  // Grand Total row
  html += `<tr class="totals-row"><td colspan="${summaryCols.length}">Grand Total</td>`;
  if (groupMode !== "none") gks.forEach(g => html += `<td>${totals[g]}</td>`);
  html += `<td>${totals.total}</td></tr></table>`;

  document.getElementById("summaryTable").innerHTML = html;
}

function downloadCSV() {
  const table = document.querySelector("#summaryTable table");
  if (!table) {
    alert("No summary table found!");
    return;
  }

  // Array to hold the final, flattened CSV rows
  const csvRows = [];

  // Array to track the current value and remaining span of the "virtual" columns (from previous rowspans)
  const virtualColValues = [];

  // --- 1. Process Header ---
  const headerRow = table.querySelector("thead tr");
  if (headerRow) {
    // Note: Colspan in the header is usually fine, but it might lead to merged headers in the CSV.
    // For simplicity, we just extract the text content here.
    const headerCells = [...headerRow.cells].map(c => `"${c.textContent.replace(/"/g, '""')}"`);
    csvRows.push(headerCells.join(","));
  }

  // --- 2. Process Body Rows ---
  const bodyRows = [...table.querySelectorAll("tbody tr")];
  
  bodyRows.forEach((row, rowIndex) => {
    const outputRow = [];
    const cellElements = [...row.cells];
    let cellIndex = 0; // Tracks the index of the PHYSICAL cell element

    // Iterate through the maximum logical column count required (based on the previous row's state)
    // We assume the final number of columns is established by the end of the first few rows.
    
    // Determine the maximum logical columns to process in this row.
    // This is a reasonable guess: total virtual slots + remaining physical cells.
    const maxLogicalCols = virtualColValues.length + cellElements.length;

    for (let logicalColIndex = 0; logicalColIndex < maxLogicalCols; logicalColIndex++) {
        
        // A. Handle Rowspan (Filling Gaps)
        // Check if the current logical column is currently being spanned by a previous row's cell
        if (logicalColIndex < virtualColValues.length && virtualColValues[logicalColIndex].span > 0) {
            outputRow.push(`"${virtualColValues[logicalColIndex].value.replace(/"/g, '""')}"`);
            virtualColValues[logicalColIndex].span--; // Decrement the remaining span
        
        } 
        // B. Handle Physical Cell (New Data)
        else if (cellIndex < cellElements.length) {
            const cell = cellElements[cellIndex];
            const value = cell.textContent;
            
            // 1. Get Colspan
            const colspan = parseInt(cell.getAttribute('colspan') || '1', 10);
            
            // 2. Insert the cell's content
            outputRow.push(`"${value.replace(/"/g, '""')}"`);

            // 3. Handle Colspan: Insert blank columns to the right if colspan > 1
            if (colspan > 1) {
                for (let k = 1; k < colspan; k++) {
                    outputRow.push(""); // Insert an empty string for the merged column
                }
                // Advance the logical column index by (colspan - 1) to skip the blank columns
                logicalColIndex += (colspan - 1);
            }

            // 4. Handle Rowspan: Store cell for future rows
            const rowspan = parseInt(cell.getAttribute('rowspan') || '1', 10);
            if (rowspan > 1) {
                // Store the value and remaining span (rowspan - 1)
                // Use the starting logicalColIndex as the key for storage
                if (logicalColIndex < virtualColValues.length) {
                    virtualColValues[logicalColIndex] = { value: value, span: rowspan - 1 };
                } else {
                    virtualColValues.push({ value: value, span: rowspan - 1 });
                }
            }
            
            cellIndex++; // Move to the next physical cell element
        }
        // C. If neither A nor B, the row is shorter than expected (e.g., in a total row)
        // This is where things get tricky in dynamic tables. For a fixed total column, 
        // we generally rely on the Colspan logic to pad the front, and the Rowspan logic 
        // to determine the maximum width.
    }
    
    // Add the completed, flattened row to the CSV data
    csvRows.push(outputRow.join(","));
  });

  // --- 3. Create and Download the CSV ---
  const blob = new Blob([csvRows.join("\n")], { type: "text/csv" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  
  a.href = url;
  a.download = "summary.csv";
  a.click();
  
  // Clean up
  URL.revokeObjectURL(url);
}

function printTable() {
    const tableContainer = document.querySelector("#summaryTable");
    
    if (!tableContainer) {
        alert("Error: The container with ID '#summaryTable' was not found.");
        return;
    }

    const tableHTML = tableContainer.innerHTML;
    const printWindow = window.open('', '', 'height=600,width=800');
    
    // Get current date and format it for the CSS variable
    const printDate = new Date().toLocaleDateString('en-US', { 
        year: 'numeric', month: 'long', day: 'numeric' 
    });

    // --- 1. Start Writing Print Window Content ---
    printWindow.document.write('<html><head><title>Summary Table Print</title>');
    
    // Copy Stylesheets (External CSS)
    document.head.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
        printWindow.document.write('<link rel="stylesheet" type="text/css" href="' + link.href + '">');
    });
    // Copy Internal Styles (<style> tags)
    document.head.querySelectorAll('style').forEach(style => {
        printWindow.document.write(style.outerHTML);
    });

    // --- 2. Inject Critical Print CSS for Headers and Footers ---
    printWindow.document.write('<style>');
    
    printWindow.document.write(`
        @media print {
            /* General Reset/Fixes */
            html, body { 
                margin: 0; 
                padding: 0; 
                /* Ensures the date variable is active for all pages */
                --print-date: '${printDate}'; 
            }
            
            /* Table Header Fix: MUST apply to the THEAD element */
            #summaryTable table thead { 
                display: table-header-group; 
            }
            
            /* Fallback/Reinforcement for older browsers or conflicts */
            #summaryTable table { 
                border-collapse: collapse; 
                margin-top: 10px; 
            }
            
            /* The key for consistent footers and page numbering on every page */
            @page {
                /* Set margins to ensure text doesn't overlap the printed content */
                margin-top: 1cm;
                margin-bottom: 1.5cm;
                
                /* Bottom Margin Left: Print Date (Reads the variable from the body) */
                @bottom-left {
                    content: "Printed on: " var(--print-date);
                    font-size: 10pt;
                    color: #555;
                }
                
                /* Bottom Margin Right: Page X of Y */
                @bottom-right {
                    content: "Page " counter(page) " of " counter(pages);
                    font-size: 10pt;
                    color: #555;
                }
            }
        }
    `);
    printWindow.document.write('</style>');
    
    printWindow.document.write('</head>');

    // --- 3. Write HTML Content and Set CSS Variable ---
    // Note: We use the inline style on the body here as a reliable fallback for the CSS variable
    printWindow.document.write(`<body style="--print-date: '${printDate}';">`); 
    printWindow.document.write('<div id="summaryTable">' + tableHTML + '</div>');
    
    printWindow.document.write('</body></html>');
    printWindow.document.close();

    // --- 4. Trigger Print ---
    printWindow.focus();
    printWindow.print();
}
</script>
</body>
</html>
